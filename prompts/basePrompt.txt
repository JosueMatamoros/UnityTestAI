You are an expert Software Engineer specialized in testing and quality assurance. Your task is to generate unit tests using White Box methods.
Objective:
Generate the absolute minimum number of Unity Test Framework (NUnit 3.x) test methods required to achieve 100% decision coverage for the given C# code. Decision coverage means every conditional branch (true and false) must be executed at least once. Do not generate any additional tests beyond what is strictly necessary.
Scope:
•	Only generate tests for the CheckHorizontal method of the class Utilities.
•	Do not test other methods, functions, or behaviors outside this method.
•	Use Condition/Decision coverage, leveraging truth tables to cover all composed conditions.
•	Achieve 100% line, condition, and condition/decision coverage.
Test Class Requirements:
•	Generate the complete test class for the target component/class.
•	Parameterize all tests using only NUnit features supported by Unity Test Framework ([TestCase], [TestCaseSource], [ValueSource]).
•	For coroutine-style tests, use [UnityTest] with [TestCaseSource] when parameters are needed.
•	Provide clear, strongly-typed test case sources for complex input objects.
•	Include all necessary using statements and namespaces.
•	Use only the dependencies listed in the project’s manifest.json file. This includes :
    o	Unity Test Framework (com.unity.test-framework)
    o	Any NuGet packages installed (e.g., Moq for mocking)
    o	Existing scripts in the project
    o	Do not introduce any new external libraries or dependencies.
    o	Ensure the correct folder path is used (e.g., Assets/test/) with proper package/import statements.
Code Quality and Conventions:
•	Do not generate code that produces bugs, issues, or code smells.
•	All objects must be fully and correctly initialized.
•	For numeric inputs, include both positive and negative values.
•	Code must pass static analysis (e.g., SonarCloud/SonarQube) without errors.
•	Use proper naming conventions and organize tests following Clean Code principles.
•	Repeated code must be factored using [SetUp] and [TearDown] as needed.
•	Include short and comprehensive test descriptions using the Description property in [Test] or [TestCase] / [TestCaseSource].
•	Implement tests using Test Engineering heuristics; ideally, one assertion per test.
Test Method Constraints:
•	Each test method must:
    o	Contain only one assertion.
    o	Be annotated with [Timeout(1000)].
    o	Have cyclomatic complexity = 1 (no branching in the test body).
    o	Have a descriptive and realistic name.
    o	Include a short explanatory comment immediately after the [Test] / [UnityTest] attribute.
Mocks and Helpers:
•	Do not redefine UnityEngine or third-party engine types (e.g., DG.Tweening).
•	Implement only the minimal helper/mocks necessary to isolate non-engine collaborators.
•	Use Moq (NuGet) for mocking.
•	Do not access CRUD methods from the database; use mocked classes instead.
•	Instantiate GameObjects at runtime in tests; do not use prefabs.
•	Respect encapsulation; if a method is protected, use a minimal subclass wrapper without changing behavior.
Lifecycle and Coroutine Handling:
•	For lifecycle/coroutine/tween-dependent code, prefer PlayMode tests ([UnityTest]).
•	Wait just enough time or pass zero tween duration to observe effects.
Exception Handling:
•	Use try/catch or assertThrows as appropriate.
•	Tests should never throw unhandled exceptions; they can only pass or fail.
Preconditions Before Generating Code:
•	Verify all constructors and imports are correct.
•	If any context or class information is missing, do not generate code; ask for clarification first.
•	Iteratively check and correct any internal errors before providing the final answer.
Final Requirements:
•	All tests must be in one C# class file.
•	Implement all necessary tests without redundancy to fully test the target method.
•	Do not include any TODOs.
•	Ensure the code compiles and fulfills all requirements.
Input Code:
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;


public static class Utilities
{
    /// <summary>
    /// Helper method to animate potential matches
    /// </summary>
    /// <param name="potentialMatches"></param>
    /// <returns></returns>
    public static IEnumerator AnimatePotentialMatches(IEnumerable<GameObject> potentialMatches)
    {
        for (float i = 1f; i >= 0.3f; i -= 0.1f)
        {
            foreach (var item in potentialMatches)
            {
                Color c = item.GetComponent<SpriteRenderer>().color;
                c.a = i;
                item.GetComponent<SpriteRenderer>().color = c;
            }
            yield return new WaitForSeconds(Constants.OpacityAnimationFrameDelay);
        }
        for (float i = 0.3f; i <= 1f; i += 0.1f)
        {
            foreach (var item in potentialMatches)
            {
                Color c = item.GetComponent<SpriteRenderer>().color;
                c.a = i;
                item.GetComponent<SpriteRenderer>().color = c;
            }
            yield return new WaitForSeconds(Constants.OpacityAnimationFrameDelay);
        }
    }

    /// <summary>
    /// Checks if a shape is next to another one
    /// either horizontally or vertically
    /// </summary>
    /// <param name="s1"></param>
    /// <param name="s2"></param>
    /// <returns></returns>
    public static bool AreVerticalOrHorizontalNeighbors(Shape s1, Shape s2)
    {
        return (s1.Column == s2.Column ||
                        s1.Row == s2.Row)
                        && Mathf.Abs(s1.Column - s2.Column) <= 1
                        && Mathf.Abs(s1.Row - s2.Row) <= 1;
    }

    /// <summary>
    /// Will check for potential matches vertically and horizontally
    /// </summary>
    /// <returns></returns>
    public static IEnumerable<GameObject> GetPotentialMatches(ShapesArray shapes)
    {
        //list that will contain all the matches we find
        List<List<GameObject>> matches = new List<List<GameObject>>();
       
        for (int row = 0; row < Constants.Rows; row++)
        {
            for (int column = 0; column < Constants.Columns; column++)
            {

                var matches1 = CheckHorizontal1(row, column, shapes);
                var matches2 = CheckHorizontal2(row, column, shapes);
                var matches3 = CheckHorizontal3(row, column, shapes);
                var matches4 = CheckVertical1(row, column, shapes);
                var matches5 = CheckVertical2(row, column, shapes);
                var matches6 = CheckVertical3(row, column, shapes);

                if (matches1 != null) matches.Add(matches1);
                if (matches2 != null) matches.Add(matches2);
                if (matches3 != null) matches.Add(matches3);
                if (matches4 != null) matches.Add(matches4);
                if (matches5 != null) matches.Add(matches5);
                if (matches6 != null) matches.Add(matches6);

                //if we have >= 3 matches, return a random one
                if (matches.Count >= 3)
                    return matches[UnityEngine.Random.Range(0, matches.Count - 1)];

                //if we are in the middle of the calculations/loops
                //and we have less than 3 matches, return a random one
                if(row >= Constants.Rows / 2 && matches.Count > 0 && matches.Count <=2)
                    return matches[UnityEngine.Random.Range(0, matches.Count - 1)];
            }
        }
        return null;
    }

    public static List<GameObject> CheckHorizontal1(int row, int column, ShapesArray shapes)
    {
        if (column <= Constants.Columns - 2)
        {
            if (shapes[row, column].GetComponent<Shape>().
                IsSameType(shapes[row, column + 1].GetComponent<Shape>()))
            {
                if (row >= 1 && column >= 1)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row - 1, column - 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row - 1, column - 1]
                                };

                /* example *\
                 * * * * *
                 * * * * *
                 * * * * *
                 * & & * *
                 & * * * *
                \* example  */

                if (row <= Constants.Rows - 2 && column >= 1)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row + 1, column - 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row + 1, column - 1]
                                };

                /* example *\
                 * * * * *
                 * * * * *
                 & * * * *
                 * & & * *
                 * * * * *
                \* example  */
            }
        }
        return null;
    }


    public static List<GameObject> CheckHorizontal2(int row, int column, ShapesArray shapes)
    {
        if (column <= Constants.Columns - 3)
        {
            if (shapes[row, column].GetComponent<Shape>().
                IsSameType(shapes[row, column + 1].GetComponent<Shape>()))
            {

                if (row >= 1 && column <= Constants.Columns - 3)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row - 1, column + 2].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row - 1, column + 2]
                                };

                /* example *\
                 * * * * *
                 * * * * *
                 * * * * *
                 * & & * *
                 * * * & *
                \* example  */

                if (row <= Constants.Rows - 2 && column <= Constants.Columns - 3)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row + 1, column + 2].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row + 1, column + 2]
                                };

                /* example *\
                 * * * * *
                 * * * * *
                 * * * & *
                 * & & * *
                 * * * * *
                \* example  */
            }
        }
        return null;
    }

    public static List<GameObject> CheckHorizontal3(int row, int column, ShapesArray shapes)
    {
        if (column <= Constants.Columns - 4)
        {
            if (shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row, column + 1].GetComponent<Shape>()) &&
               shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row, column + 3].GetComponent<Shape>()))
            {
                return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row, column + 3]
                                };
            }

            /* example *\
              * * * * *  
              * * * * *
              * * * * *
              * & & * &
              * * * * *
            \* example  */
        }
        if (column >= 2 && column <= Constants.Columns - 2)
        {
            if (shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row, column + 1].GetComponent<Shape>()) &&
               shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row, column - 2].GetComponent<Shape>()))
            {
                return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row, column + 1],
                                    shapes[row, column -2]
                                };
            }

            /* example *\
              * * * * * 
              * * * * *
              * * * * *
              * & * & &
              * * * * *
            \* example  */
        }
        return null;
    }

    public static List<GameObject> CheckVertical1(int row, int column, ShapesArray shapes)
    {
        if (row <= Constants.Rows - 2)
        {
            if (shapes[row, column].GetComponent<Shape>().
                IsSameType(shapes[row + 1, column].GetComponent<Shape>()))
            {
                if (column >= 1 && row >= 1)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row - 1, column - 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row + 1, column],
                                    shapes[row - 1, column -1]
                                };

                /* example *\
                  * * * * *
                  * * * * *
                  * & * * *
                  * & * * *
                  & * * * *
                \* example  */

                if (column <= Constants.Columns - 2 && row >= 1)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row - 1, column + 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row + 1, column],
                                    shapes[row - 1, column + 1]
                                };

                /* example *\
                  * * * * *
                  * * * * *
                  * & * * *
                  * & * * *
                  * * & * *
                \* example  */
            }
        }
        return null;
    }

    public static List<GameObject> CheckVertical2(int row, int column, ShapesArray shapes)
    {
        if (row <= Constants.Rows - 3)
        {
            if (shapes[row, column].GetComponent<Shape>().
                IsSameType(shapes[row + 1, column].GetComponent<Shape>()))
            {
                if (column >= 1)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row + 2, column - 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row + 1, column],
                                    shapes[row + 2, column -1]
                                };

                /* example *\
                  * * * * *
                  & * * * *
                  * & * * *
                  * & * * *
                  * * * * *
                \* example  */

                if (column <= Constants.Columns - 2)
                    if (shapes[row, column].GetComponent<Shape>().
                    IsSameType(shapes[row + 2, column + 1].GetComponent<Shape>()))
                        return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row+1, column],
                                    shapes[row + 2, column + 1]
                                };

                /* example *\
                  * * * * *
                  * * & * *
                  * & * * *
                  * & * * *
                  * * * * *
                \* example  */

            }
        }
        return null;
    }

    public static List<GameObject> CheckVertical3(int row, int column, ShapesArray shapes)
    {
        if (row <= Constants.Rows - 4)
        {
            if (shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row + 1, column].GetComponent<Shape>()) &&
               shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row + 3, column].GetComponent<Shape>()))
            {
                return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row + 1, column],
                                    shapes[row + 3, column]
                                };
            }
        }

        /* example *\
          * & * * *
          * * * * *
          * & * * *
          * & * * *
          * * * * *
        \* example  */

        if (row >= 2 && row <= Constants.Rows - 2)
        {
            if (shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row + 1, column].GetComponent<Shape>()) &&
               shapes[row, column].GetComponent<Shape>().
               IsSameType(shapes[row - 2, column].GetComponent<Shape>()))
            {
                return new List<GameObject>()
                                {
                                    shapes[row, column],
                                    shapes[row + 1, column],
                                    shapes[row - 2, column]
                                };
            }
        }

        /* example *\
          * * * * *
          * & * * *
          * & * * *
          * * * * *
          * & * * *
        \* example  */
        return null;
    }


}

Instruction:
YOU MUST IMPLEMENT ALL TESTS! I WILL NOT CODE ANYTHING! DO ALL ASSERTIONS! DO NOT ADD ANY TODO LINE. THE CODE MUST COMPILE AND FULFILL ALL THE REQUIREMENTS EXPLAINED ABOVE!

